<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>StreetSim Ultra — Presets & Max Control (Synthetic)</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>
<style>
  html,body,#map{height:100%;margin:0;padding:0}
  :root{
    --panel-bg:rgba(6,12,22,0.95);
    --accent:#38bdf8;
    --muted:#9fb6cf;
    --glass: rgba(255,255,255,0.03);
  }
  /* toggle button */
  .toggle-panel{
    position:absolute;top:14px;right:14px;z-index:1400;
    background:var(--accent);color:#02121a;border:none;border-radius:50%;
    width:46px;height:46px;font-size:20px;cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,0.45)
  }
  /* control panel */
  .panel{
    position:absolute;left:14px;top:14px;z-index:1300;width:420px;max-height:90vh;overflow:auto;
    background:var(--panel-bg);color:#eaf6ff;border-radius:12px;padding:12px;font-family:Inter,system-ui;
    box-shadow:0 14px 40px rgba(0,0,0,0.6)
  }
  .panel.maximized{width:720px}
  .panel h2{margin:0;font-size:18px}
  .muted{color:var(--muted);font-size:13px}
  .row{display:flex;gap:8px;align-items:center;margin-top:8px}
  .small{font-size:13px;color:var(--muted)}
  .btn{border:none;padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:700}
  .btn.primary{background:var(--accent);color:#02121a}
  .btn.ghost{background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.06)}
  label{font-size:13px;color:var(--muted);display:block;margin-top:8px}
  input[type="range"],select,input[type="text"],input[type="color"]{width:100%;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04)}
  .section{margin-top:12px;padding-top:10px;border-top:1px solid rgba(255,255,255,0.04)}
  /* HUD */
  .hud{position:absolute;right:14px;top:14px;z-index:1300;width:320px;max-height:90vh;overflow:auto;
       background:rgba(2,6,23,0.82);color:#eaf6ff;border-radius:12px;padding:10px;font-family:Inter,system-ui}
  .hud h3{margin:0 0 8px 0;font-size:16px}
  .agent-row{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;background:var(--glass);margin-bottom:6px}
  .agent-meta{font-size:12px;color:var(--muted)}
  .kbd{background:rgba(255,255,255,0.04);padding:4px 6px;border-radius:6px;font-weight:700}
  footer.small{font-size:12px;color:var(--muted);margin-top:8px}
</style>
</head>
<body>
<div id="map"></div>

<button id="togglePanel" class="toggle-panel" title="Toggle panel">⚙️</button>

<div class="panel" id="controlPanel" role="region" aria-label="StreetSim controls">
  <div style="display:flex;justify-content:space-between;align-items:center">
    <h2>StreetSim Ultra — Presets & Controls</h2>
    <div style="display:flex;gap:8px">
      <button id="maximize" class="btn ghost" title="Maximize panel">⬜</button>
      <button id="closePanel" class="btn ghost" title="Close panel">✕</button>
    </div>
  </div>
  <div class="muted">Fully synthetic — uses OSRM for street-following geometry. Preset lights & signs, editable colors, automatic cycling. Use for UI/testing only.</div>

  <div class="section">
    <label>Agent name</label>
    <input id="agentName" type="text" placeholder="Type a name or leave blank"/>
    <label>Profile</label>
    <select id="agentProfile"><option value="drive">Drive</option><option value="bike">Bike</option><option value="walk">Walk</option></select>

    <label style="margin-top:8px">Agent marker color</label>
    <input id="agentColor" type="color" value="#ff7f0e"/>

    <div class="row" style="margin-top:8px">
      <button id="addAgent" class="btn primary">Add Agent</button>
      <button id="spawn5" class="btn ghost">Spawn 5</button>
      <button id="removeAgent" class="btn ghost">Remove Last</button>
    </div>
  </div>

  <div class="section">
    <label>Traffic light red color</label>
    <input id="lightRed" type="color" value="#ff3b3b"/>
    <label>Traffic light green color</label>
    <input id="lightGreen" type="color" value="#7CFC00"/>
    <label>Stop sign color</label>
    <input id="stopColor" type="color" value="#ff8c00"/>
    <div class="row">
      <label>Auto-cycle lights</label>
      <input id="autoCycle" type="checkbox" checked style="margin-left:auto"/>
    </div>
    <label>Light cycle duration (seconds)</label>
    <input id="cycleDuration" type="range" min="4" max="30" step="1" value="10"/>
  </div>

  <div class="section">
    <label>Speed multiplier <span id="speedMultLabel">1.0×</span></label>
    <input id="speedMult" type="range" min="0.25" max="3" step="0.25" value="1"/>
    <div class="row">
      <label>Realistic behavior</label>
      <input id="realistic" type="checkbox" checked style="margin-left:auto"/>
    </div>
    <div class="row">
      <button id="presetLights" class="btn ghost">Place Preset Lights</button>
      <button id="presetStops" class="btn ghost">Place Preset Stops</button>
      <button id="clearControls" class="btn ghost">Clear Lights/Stops</button>
    </div>
  </div>

  <div class="section">
    <label>Congestion: Draw zones</label>
    <div class="row">
      <button id="drawZone" class="btn ghost">Draw Zone</button>
      <button id="clearZones" class="btn ghost">Clear Zones</button>
    </div>
  </div>

  <div class="section">
    <div class="row">
      <button id="pauseAll" class="btn ghost">Pause/Resume</button>
      <button id="toggleTrails" class="btn ghost">Toggle Trails</button>
      <button id="exportCSV" class="btn ghost">Export CSV</button>
      <button id="replayLast" class="btn ghost">Replay Last Trace</button>
    </div>
  </div>

  <footer class="small">Keyboard: A = add, P = pause, T = toggle trails. Click map to reroute the last agent.</footer>
</div>

<div class="hud" id="hud">
  <h3>Agents Dashboard</h3>
  <div id="agentList"></div>
  <div style="margin-top:8px" class="small">Hover a row to focus agent. Use Focus / Remove buttons. Presets place lights near the center/grid intersections.</div>
</div>

<!-- libs -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

<script>
/* StreetSim Ultra — Presets & Max Control
   - Single-file browser app (synthetic only)
   - OSRM public router used for route geometry
   - Preset lights/stop signs, color customization, full control panel
*/

/* ======= Configuration ======= */
const OSRM_BASE = 'https://router.project-osrm.org';
const SPEEDS = { walk:1.4, bike:5.0, drive:13.0 };
const DEFAULT_LIGHT_CYCLE = 10; // seconds

/* ======= Utilities ======= */
function rand(a,b){ return a + Math.random()*(b-a); }
function toRad(x){ return x * Math.PI / 180; }
function haversine(a,b){
  const R = 6371000;
  const dLat = toRad(b.lat - a.lat), dLon = toRad(b.lng - a.lng);
  const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
  const sinDlat = Math.sin(dLat/2), sinDlon = Math.sin(dLon/2);
  const aa = sinDlat*sinDlat + Math.cos(lat1)*Math.cos(lat2)*sinDlon*sinDlon;
  const c = 2 * Math.atan2(Math.sqrt(aa), Math.sqrt(1-aa));
  return R * c;
}
function lerp(a,b,t){ return { lat: a.lat + (b.lat - a.lat)*t, lng: a.lng + (b.lng - a.lng)*t }; }
function escapeCSV(s){ if(s==null) return ''; return `"${String(s).replace(/"/g,'""')}"`; }

/* ======= Map setup (satellite) ======= */
const map = L.map('map', {preferCanvas:true}).setView([40.730610, -73.935242], 14);
L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  attribution: 'Esri World Imagery',
  maxZoom: 20
}).addTo(map);

/* ======= Global state ======= */
let agents = new Map();           // id -> Agent
let lights = new Map();           // id -> TrafficLight
let stops = new Map();            // id -> StopSign
let zones = [];                   // polygon arrays of lat/lng
let lastTraces = [];              // saved traces for replay/export
let nextAgentId = 1;
let running = true;
let speedMultiplier = 1.0;
let realistic = true;
let trailsVisible = true;
let autoCycle = true;
let cycleDuration = DEFAULT_LIGHT_CYCLE; // seconds
let selectedObject = null; // for manual toggle etc.

/* ======= Draw control (for zones) ======= */
const drawnItems = new L.FeatureGroup().addTo(map);
let drawControl = new L.Control.Draw({
  edit: { featureGroup: drawnItems, edit: false, remove: true },
  draw: { polygon:false, circle:false, polyline:false, marker:false, rectangle:true }
});

/* ======= OSRM route helper ======= */
async function fetchRouteGeojson(aLatLng, bLatLng) {
  const coords = `${aLatLng.lng},${aLatLng.lat};${bLatLng.lng},${bLatLng.lat}`;
  const url = `${OSRM_BASE}/route/v1/driving/${coords}?overview=full&geometries=geojson&steps=false`;
  const r = await fetch(url);
  if(!r.ok) throw new Error('Routing error ' + r.status);
  const j = await r.json();
  if(!j.routes || !j.routes.length) return null;
  return j.routes[0].geometry.coordinates; // [ [lng,lat], ... ]
}

/* ======= Traffic control classes ======= */
class TrafficLight {
  constructor(latlng, redColor='#ff3b3b', greenColor='#7CFC00', cycleSecs=DEFAULT_LIGHT_CYCLE){
    this.id = 'TL-' + (Math.random().toString(36).slice(2,8));
    this.latlng = latlng;
    this.redColor = redColor;
    this.greenColor = greenColor;
    this.state = Math.random() < 0.5 ? 'red' : 'green'; // initial
    this.marker = L.circleMarker(latlng, { radius:9, fillColor: this.state==='red'?this.redColor:this.greenColor, color:'#111', fillOpacity:1 }).addTo(map);
    this.marker.on('click', ()=> { selectedObject = this; highlightSelected(); });
    this.cycleSecs = cycleSecs;
    this._timer = null;
    if(autoCycle) this.startAutoCycle();
  }
  startAutoCycle(){
    if(this._timer) clearInterval(this._timer);
    this._timer = setInterval(()=> this.toggle(), this.cycleSecs * 1000);
  }
  stopAutoCycle(){ if(this._timer){ clearInterval(this._timer); this._timer = null; } }
  setCycle(secs){ this.cycleSecs = secs; this.stopAutoCycle(); if(autoCycle) this.startAutoCycle(); }
  toggle(){
    this.state = (this.state === 'red') ? 'green' : 'red';
    this.marker.setStyle({ fillColor: this.state === 'red' ? this.redColor : this.greenColor });
  }
  setColors(red, green){
    this.redColor = red; this.greenColor = green;
    this.marker.setStyle({ fillColor: this.state === 'red' ? this.redColor : this.greenColor });
  }
  remove(){ map.removeLayer(this.marker); lights.delete(this.id); }
}

class StopSign {
  constructor(latlng, color='#ff8c00'){
    this.id = 'SS-' + (Math.random().toString(36).slice(2,8));
    this.latlng = latlng;
    this.color = color;
    this.marker = L.circleMarker(latlng, { radius:8, fillColor: this.color, color:'#111', fillOpacity:1 }).addTo(map);
    this.marker.on('click', ()=> { selectedObject = this; highlightSelected(); });
    // passed set to prevent repeated stops
    this.passed = new Set();
    stops.set(this.id, this);
  }
  setColor(c){
    this.color = c;
    this.marker.setStyle({ fillColor: c });
  }
  remove(){ map.removeLayer(this.marker); stops.delete(this.id); }
}

/* ======= Agent class ======= */
class Agent {
  constructor(name, profile, coordsLonLat, baseSpeed, color){
    this.id = 'AG' + nextAgentId++;
    this.name = name || this.id;
    this.profile = profile || 'drive';
    this.points = coordsLonLat.map(c => ({ lat: c[1], lng: c[0] }));
    if (this.points.length < 2) this.points = [this.points[0], this.points[0]];
    // cumulative distances
    this.dist = [0];
    for (let i=1;i<this.points.length;i++) this.dist[i] = this.dist[i-1] + haversine(this.points[i-1], this.points[i]);
    this.total = this.dist[this.dist.length-1] || 0;
    this.progress = 0;
    this.baseSpeed = baseSpeed || SPEEDS.drive;
    this.speed = 0;
    this.targetSpeed = this.baseSpeed;
    this.speedJitter = (this.profile === 'walk') ? 0.32 : (this.profile === 'bike' ? 0.18 : 0.10);
    this.pauseUntil = 0;
    this.state = 'moving';
    this.color = color || COLORS[Math.floor(Math.random()*COLORS.length)];
    // map layers
    this.marker = L.circleMarker(this.points[0], { radius:8, fillColor: this.color, color:'#02121A', weight:1, fillOpacity:1 }).addTo(map);
    this.marker.bindTooltip(this.name, { permanent:true, direction: 'right', offset: [10,0] });
    this.trail = L.polyline([], { color: this.color, weight: 3, opacity: trailsVisible ? 0.9 : 0.0 }).addTo(map);
    this.polyline = L.polyline(this.points, { color: this.color, opacity: 0.12 }).addTo(map);
    this.trace = []; // store samples for export
    this.lastSample = 0;
  }
  getPosAt(m){
    if (this.total <= 0) return this.points[0];
    if (m <= 0) return this.points[0];
    if (m >= this.total) return this.points[this.points.length-1];
    // binary search for segment
    let lo = 0, hi = this.dist.length - 1;
    while (lo < hi) {
      const mid = Math.floor((lo + hi) / 2);
      if (this.dist[mid] < m) lo = mid + 1; else hi = mid;
    }
    const i = Math.max(1, lo);
    const segStart = this.dist[i-1], segEnd = this.dist[i];
    const t = (m - segStart) / (segEnd - segStart);
    return lerp(this.points[i-1], this.points[i], t);
  }
  step(dt){
    const now = performance.now();
    if (this.progress >= this.total) { this.state = 'arrived'; this.speed = 0; return; }
    if (this.pauseUntil > now) { this.state = 'paused'; this.sample(now); return; }

    // desired speed with jitter
    const jitter = 1 + (rand(-this.speedJitter, this.speedJitter));
    let desired = this.baseSpeed * jitter * speedMultiplier;

    // respond to lights: if red and close, stop and set state
    const cur = this.getPosAt(this.progress);
    for (const tl of lights.values()) {
      const d = haversine(cur, { lat: tl.latlng.lat, lng: tl.latlng.lng });
      if (d < 16 && tl.state === 'red' && this.progress < this.total - 2) {
        desired = 0;
        this.state = 'stopped at red';
      }
    }

    // respond to stop signs: if close and not passed yet (per sign), pause ~3s
    for (const st of stops.values()) {
      const d = haversine(cur, { lat: st.latlng.lat, lng: st.latlng.lng });
      if (d < 12 && !st.passed.has(this.id)) {
        desired = 0;
        st.passed.add(this.id);
        this.pauseUntil = now + rand(1800, 3200);
        this.state = 'stopped at sign';
      }
    }

    // congestion zones (slow within zone)
    let congested = false;
    for (const poly of zones) {
      if (pointInPolygon(cur, poly)) { desired *= rand(0.35, 0.6); congested = true; this.state = 'congested'; }
    }
    if (!congested && this.state === 'congested') this.state = 'moving';

    // occasional random pause
    if (realistic && Math.random() < 0.0006) { this.pauseUntil = now + rand(1000, 4500); this.state = 'random pause'; return; }

    // smooth acceleration
    const accel = realistic ? 2.6 : 999;
    const diff = desired - this.speed;
    this.speed += Math.sign(diff) * Math.min(Math.abs(diff), accel * dt);

    // move
    const travel = this.speed * dt;
    this.progress += travel;
    if (this.progress > this.total) { this.progress = this.total; this.state = 'arrived'; }

    // update marker + trail
    const pos = this.getPosAt(this.progress);
    this.marker.setLatLng(pos);
    const arr = this.trail.getLatLngs(); arr.push(pos); if (arr.length > 300) arr.shift(); this.trail.setLatLngs(arr);

    // sample trace periodically
    this.sample(now);
  }
  sample(now){
    if (!this.lastSample || now - this.lastSample > 700 || this.progress >= this.total) {
      this.lastSample = now;
      const pos = this.getPosAt(this.progress);
      this.trace.push({ t: new Date().toISOString(), lat: pos.lat, lng: pos.lng, speed: this.speed.toFixed(2), state: this.state });
    }
  }
  remove(){
    // save trace for replay
    lastTraces.push({ id: this.id, name: this.name, profile: this.profile, trace: this.trace.slice() });
    if (this.marker) map.removeLayer(this.marker);
    if (this.trail) map.removeLayer(this.trail);
    if (this.polyline) map.removeLayer(this.polyline);
  }
}

/* ======= Helper functions ======= */
function pointInPolygon(pt, poly){
  // poly is array of {lat,lng}, ray-casting
  let x = pt.lng, y = pt.lat, inside = false;
  for (let i=0,j=poly.length-1; i<poly.length; j=i++){
    const xi = poly[i].lng, yi = poly[i].lat;
    const xj = poly[j].lng, yj = poly[j].lat;
    const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / ((yj - yi) || 1e-9) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}
function downloadBlob(content, name, type='text/csv'){ const blob = new Blob([content], { type }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = name; a.click(); URL.revokeObjectURL(url); }

/* ======= UI bindings ======= */
const panel = document.getElementById('controlPanel');
const togglePanelBtn = document.getElementById('togglePanel');
const maximizeBtn = document.getElementById('maximize');
const closePanelBtn = document.getElementById('closePanel');
const addAgentBtn = document.getElementById('addAgent');
const spawn5Btn = document.getElementById('spawn5');
const removeAgentBtn = document.getElementById('removeAgent');
const agentNameInput = document.getElementById('agentName');
const agentProfileSelect = document.getElementById('agentProfile');
const agentColorInput = document.getElementById('agentColor');
const lightRedInput = document.getElementById('lightRed');
const lightGreenInput = document.getElementById('lightGreen');
const stopColorInput = document.getElementById('stopColor');
const autoCycleCheckbox = document.getElementById('autoCycle');
const cycleDurationInput = document.getElementById('cycleDuration');
const presetLightsBtn = document.getElementById('presetLights');
const presetStopsBtn = document.getElementById('presetStops');
const clearControlsBtn = document.getElementById('clearControls');
const drawZoneBtn = document.getElementById('drawZone');
const clearZonesBtn = document.getElementById('clearZones');
const speedMultInput = document.getElementById('speedMult');
const speedMultLabel = document.getElementById('speedMultLabel');
const realisticCheckbox = document.getElementById('realistic');
const pauseAllBtn = document.getElementById('pauseAll');
const toggleTrailsBtn = document.getElementById('toggleTrails');
const exportCSVBtn = document.getElementById('exportCSV');
const replayLastBtn = document.getElementById('replayLast');
const hudList = document.getElementById('agentList');

/* toggle panel */
togglePanelBtn.onclick = ()=> panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
closePanelBtn.onclick = ()=> panel.style.display = 'none';
maximizeBtn.onclick = ()=> panel.classList.toggle('maximized');

/* speed multiplier */
speedMultInput.oninput = (e)=> { speedMultiplier = parseFloat(e.target.value); speedMultLabel.textContent = speedMultiplier.toFixed(2) + '×'; };

/* realistic toggle */
realisticCheckbox.onchange = ()=> realistic = realisticCheckbox.checked;

/* add agent */
addAgentBtn.onclick = async () => {
  addAgentBtn.disabled = true;
  try {
    const name = agentNameInput.value.trim() || null;
    const profile = agentProfileSelect.value;
    const color = agentColorInput.value || COLORS[Math.floor(Math.random()*COLORS.length)];
    const bounds = map.getBounds();
    const origin = L.latLng(rand(bounds.getSouth(), bounds.getNorth()), rand(bounds.getWest(), bounds.getEast()));
    const dest = L.latLng(rand(bounds.getSouth(), bounds.getNorth()), rand(bounds.getWest(), bounds.getEast()));
    const coords = await fetchRouteGeojson(origin, dest);
    if (!coords || coords.length < 2) { alert('Routing failed (try panning or try again)'); return; }
    const agent = new Agent(name || ('Agent ' + nextAgentId), profile, coords, SPEEDS[profile], color);
    agents.set(agent.id, agent);
    renderHUD();
  } catch (err) {
    console.error(err); alert('Add agent error: ' + err.message);
  } finally {
    addAgentBtn.disabled = false;
  }
};

/* spawn 5 quickly */
spawn5Btn.onclick = async () => {
  spawn5Btn.disabled = true;
  for (let i=0;i<5;i++){
    await new Promise(r => setTimeout(r, 200));
    addAgentBtn.click();
  }
  spawn5Btn.disabled = false;
};

/* remove last */
removeAgentBtn.onclick = () => {
  const keys = Array.from(agents.keys());
  if (!keys.length) return;
  const last = keys[keys.length-1];
  const a = agents.get(last);
  a.remove();
  agents.delete(last);
  renderHUD();
};

/* preset lights: grid around center */
presetLightsBtn.onclick = () => {
  const center = map.getCenter();
  const step = 0.005; // small grid spacing (~500m)
  const positions = [
    [center.lat, center.lng],
    [center.lat + step, center.lng + step],
    [center.lat + step, center.lng - step],
    [center.lat - step, center.lng + step],
    [center.lat - step, center.lng - step]
  ];
  positions.forEach((p, idx) => {
    const tl = new TrafficLight(L.latLng(p[0], p[1]), lightRedInput.value, lightGreenInput.value, parseInt(cycleDurationInput.value) || DEFAULT_LIGHT_CYCLE);
    lights.set(tl.id, tl);
  });
};

/* preset stops: small ring around center */
presetStopsBtn.onclick = () => {
  const center = map.getCenter();
  const step = 0.004;
  const positions = [
    [center.lat + step, center.lng],
    [center.lat - step, center.lng],
    [center.lat, center.lng + step],
    [center.lat, center.lng - step]
  ];
  positions.forEach(p => {
    const s = new StopSign(L.latLng(p[0], p[1]), stopColorInput.value);
    stops.set(s.id, s);
  });
};

/* clear controls */
clearControlsBtn.onclick = () => {
  lights.forEach(l => l.remove()); lights.clear();
  stops.forEach(s => s.remove()); stops.clear();
  selectedObject = null;
};

/* draw zone */
drawZoneBtn.onclick = () => {
  map.addControl(drawControl);
  alert('Draw a rectangle on the map to place a congestion zone.');
};
map.on(L.Draw.Event.CREATED, function (e) {
  const layer = e.layer;
  if (layer instanceof L.Rectangle) {
    drawnItems.addLayer(layer);
    const latlngs = layer.getLatLngs()[0].map(ll => ({ lat: ll.lat, lng: ll.lng }));
    zones.push(latlngs);
  }
  map.removeControl(drawControl);
});

/* clear zones */
clearZonesBtn.onclick = () => {
  zones = [];
  drawnItems.clearLayers();
};

/* auto-cycle checkbox and cycle duration */
autoCycleCheckbox.onchange = () => {
  autoCycle = autoCycleCheckbox.checked;
  lights.forEach(l => { if (autoCycle) l.startAutoCycle(); else l.stopAutoCycle(); });
};
cycleDurationInput.oninput = () => {
  cycleDuration = parseInt(cycleDurationInput.value);
  lights.forEach(l => l.setCycle(cycleDuration));
};

/* pause / resume all */
pauseAllBtn.onclick = () => { running = !running; pauseAllBtn.textContent = running ? 'Pause/Resume' : 'Paused'; };

/* toggle trails */
toggleTrailsBtn.onclick = () => {
  trailsVisible = !trailsVisible;
  agents.forEach(a => { a.trail.setStyle({ opacity: trailsVisible ? 0.9 : 0.0 }); });
};

/* export CSV */
exportCSVBtn.onclick = () => {
  let csv = 'id,name,profile,timestamp,lat,lng,speed,state\n';
  agents.forEach(a => {
    a.trace.forEach(s => csv += `${escapeCSV(a.id)},${escapeCSV(a.name)},${a.profile},${s.t},${s.lat},${s.lng},${s.speed},${escapeCSV(s.state)}\n`);
  });
  lastTraces.forEach(rec => {
    rec.trace.forEach(s => csv += `${escapeCSV(rec.id)},${escapeCSV(rec.name)},${escapeCSV(rec.profile)},${s.t},${s.lat},${s.lng},${s.speed},${escapeCSV(s.state)}\n`);
  });
  downloadBlob(csv, `streetsim_traces_${(new Date()).toISOString().replace(/[:.]/g,'-')}.csv`);
};

/* replay last */
replayLastBtn.onclick = () => {
  if (!lastTraces.length) { alert('No traces saved yet (remove or finish agents to save traces).'); return; }
  const rec = lastTraces.pop();
  replayTrace(rec);
};

/* click map: reroute last agent */
map.on('click', async (e) => {
  const keys = Array.from(agents.keys());
  if (!keys.length) return;
  const last = keys[keys.length - 1];
  const agent = agents.get(last);
  if (!agent) return;
  // remove old visuals to avoid duplicates
  if (agent.marker) map.removeLayer(agent.marker);
  if (agent.trail) map.removeLayer(agent.trail);
  if (agent.polyline) map.removeLayer(agent.polyline);

  try {
    const origin = agent.getPosAt(agent.progress); // current position
    const coords = await fetchRouteGeojson(origin, e.latlng);
    if (!coords || coords.length < 2) { alert('Routing failed'); return; }
    // create new agent object but preserve id & name & color & baseSpeed & trace
    const newAgent = new Agent(agent.name, agent.profile, coords, agent.baseSpeed, agent.color);
    // preserve id and trace by manual replacement
    newAgent.id = agent.id;
    newAgent.trace = agent.trace.slice();
    // remove old object and set the new one
    agents.delete(last);
    agents.set(newAgent.id, newAgent);
    renderHUD();
  } catch (err) {
    console.error(err); alert('Routing error: ' + err.message);
  }
});

/* keyboard shortcuts */
window.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 'a') addAgentBtn.click();
  if (e.key.toLowerCase() === 'p') pauseAllBtn.click();
  if (e.key.toLowerCase() === 't') toggleTrailsBtn.click();
});

/* highlight selected control */
function highlightSelected() {
  // briefly outline the selected object's marker
  map.eachLayer(l => {
    if (l.setStyle) l.setStyle({ weight: 1 });
  });
  if (selectedObject && selectedObject.marker && selectedObject.marker.setStyle) {
    selectedObject.marker.setStyle({ weight: 3 });
  }
}

/* render HUD */
function renderHUD(){
  const container = document.getElementById('agentList');
  container.innerHTML = '';
  agents.forEach((a, id) => {
    const div = document.createElement('div');
    div.className = 'agent-row';
    div.innerHTML = `<div>
      <div style="font-weight:700">${a.name} <span style="color:${a.color};font-weight:700">(${a.profile})</span></div>
      <div class="agent-meta">speed: ${(a.speed||0).toFixed(2)} m/s · state: ${a.state}</div>
      <div class="agent-meta">progress: ${Math.round((a.progress / (a.total||1))*100)}% · ETA: ${etaText(a)}</div>
    </div>`;
    const buttons = document.createElement('div');
    buttons.style.display = 'flex';
    buttons.style.flexDirection = 'column';
    buttons.style.gap = '6px';
    const focus = document.createElement('button');
    focus.className = 'btn ghost'; focus.textContent = 'Focus';
    focus.onclick = () => { map.panTo(a.marker.getLatLng()); a.marker.openTooltip(); };
    const rem = document.createElement('button');
    rem.className = 'btn ghost'; rem.textContent = 'Remove';
    rem.onclick = () => { a.remove(); agents.delete(id); renderHUD(); };
    buttons.appendChild(focus); buttons.appendChild(rem);
    div.appendChild(buttons);
    div.onmouseenter = () => { map.panTo(a.marker.getLatLng()); };
    container.appendChild(div);
  });
}

/* ETA text */
function etaText(agent){
  if (agent.progress >= agent.total) return 'arrived';
  const rem = Math.max(0, agent.total - agent.progress);
  const sp = Math.max(0.01, agent.speed || agent.baseSpeed * 0.5);
  const secs = Math.round(rem / sp);
  if (secs > 3600) return `${Math.round(secs/3600)}h`;
  return `${secs}s`;
}

/* replay trace simple visualizer */
function replayTrace(rec){
  if (!rec.trace || rec.trace.length < 2) { alert('Not enough points to replay'); return; }
  const coords = rec.trace.map(p => [p.lat, p.lng]);
  const poly = L.polyline(coords, { color:'#fff', weight:3, opacity:0.9 }).addTo(map);
  const marker = L.circleMarker(coords[0], { radius:8, fillColor:'#fff', color:'#02121A', weight:1, fillOpacity:1 }).addTo(map);
  map.fitBounds(poly.getBounds(), { maxZoom: 16, padding: [20,20] });
  let idx = 0;
  const iv = setInterval(()=> {
    idx++;
    if (idx >= coords.length) { clearInterval(iv); setTimeout(()=>{ map.removeLayer(poly); map.removeLayer(marker); }, 800); return; }
    marker.setLatLng(coords[idx]);
  }, 250);
}

/* ======= Main animation loop ======= */
let lastTS = performance.now();
function tick(now){
  const dt = Math.min(0.5, (now - lastTS) / 1000);
  lastTS = now;
  if (running) {
    agents.forEach(a => a.step(dt));
  }
  renderHUD();
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* ======= Auto-place some default lights & stops (preset mode) ======= */
function placeAutoPresets(){
  // take map center and make a little cross/grid of controls
  const c = map.getCenter();
  const s = 0.0035; // spacing
  const pts = [
    [c.lat, c.lng],
    [c.lat + s, c.lng],
    [c.lat - s, c.lng],
    [c.lat, c.lng + s],
    [c.lat, c.lng - s],
    [c.lat + s, c.lng + s],
    [c.lat - s, c.lng - s]
  ];
  pts.forEach((p,i) => {
    const tl = new TrafficLight(L.latLng(p[0], p[1]), document.getElementById('lightRed').value, document.getElementById('lightGreen').value, parseInt(document.getElementById('cycleDuration').value) || DEFAULT_LIGHT_CYCLE);
    lights.set(tl.id, tl);
    if (i % 3 === 0) {
      const sgn = new StopSign(L.latLng(p[0] + 0.001, p[1] + 0.001), document.getElementById('stopColor').value);
      stops.set(sgn.id, sgn);
    }
  });
}
placeAutoPresets();

/* ======= expose some helpers for color changes ======= */
document.getElementById('lightRed').addEventListener('input', (e) => {
  const red = e.target.value;
  lights.forEach(l => { l.redColor = red; l.marker.setStyle({ fillColor: l.state === 'red' ? red : l.greenColor }); });
});
document.getElementById('lightGreen').addEventListener('input', (e) => {
  const green = e.target.value;
  lights.forEach(l => { l.greenColor = green; l.marker.setStyle({ fillColor: l.state === 'green' ? green : l.redColor }); });
});
document.getElementById('stopColor').addEventListener('input', (e) => {
  const c = e.target.value;
  stops.forEach(s => s.setColor(c));
});
document.getElementById('agentColor').addEventListener('input', (e) => {
  // change color for newly created agents; optionally update selected agent
});

/* ======= fetchRoute wrapper used earlier ======= */
async function fetchRouteGeojson(aLatLng, bLatLng) {
  const coords = `${aLatLng.lng},${aLatLng.lat};${bLatLng.lng},${bLatLng.lat}`;
  const url = `${OSRM_BASE}/route/v1/driving/${coords}?overview=full&geometries=geojson&steps=false`;
  const r = await fetch(url);
  if (!r.ok) throw new Error('Routing error ' + r.status);
  const j = await r.json();
  if (!j.routes || !j.routes.length) return null;
  return j.routes[0].geometry.coordinates;
}

/* ======= Initial demo agents (safe, small count) ======= */
(async function init() {
  // spawn one drive and one walk to show difference
  for (let i=0;i<2;i++){
    try {
      const bounds = map.getBounds();
      const origin = L.latLng(rand(bounds.getSouth(), bounds.getNorth()), rand(bounds.getWest(), bounds.getEast()));
      const dest = L.latLng(rand(bounds.getSouth(), bounds.getNorth()), rand(bounds.getWest(), bounds.getEast()));
      const coords = await fetchRouteGeojson(origin, dest);
      if (!coords || coords.length < 2) continue;
      const profile = i===0 ? 'drive' : 'walk';
      const color = COLORS[i % COLORS.length];
      const agent = new Agent(profile === 'drive' ? 'Car ' + (i+1) : 'Walker ' + (i+1), profile, coords, SPEEDS[profile], color);
      agents.set(agent.id, agent);
    } catch (err) { console.warn('init spawn fail', err); }
  }
})();

/* ======= Utility: distance & point-in-poly used above (repeat for safety) ======= */
function distance(a,b){ return haversine(a,b); }

function pointInPolygon(pt, poly){
  let x = pt.lng, y = pt.lat, inside = false;
  for (let i=0,j=poly.length-1;i<poly.length;j=i++){
    const xi = poly[i].lng, yi = poly[i].lat;
    const xj = poly[j].lng, yj = poly[j].lat;
    const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / ((yj - yi) || 1e-9) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

/* ======= End of script ======= */
</script>
</body>
</html>
