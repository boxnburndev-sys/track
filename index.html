<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Street-following Sim (Leaflet + OSRM) — Synthetic Only</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="" crossorigin=""/>
<style>
  html,body,#map { height:100%; margin:0; padding:0; }
  .controls {
    position: absolute;
    left: 12px;
    top: 12px;
    z-index:1000;
    background: rgba(10,15,25,0.85);
    color:#eaf6ff;
    padding:10px;
    border-radius:8px;
    box-shadow: 0 6px 20px rgba(0,0,0,0.6);
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    min-width:240px;
  }
  .controls button { margin:4px 4px 4px 0; padding:6px 10px; border-radius:6px; border:none; cursor:pointer; font-weight:600;}
  .btn-ghost { background:transparent; color:#a9c4e8; border:1px solid rgba(255,255,255,0.06); }
  .btn-primary { background:#60a5fa; color:#042033; }
  .muted { color:#a9c4e8; font-size:13px; margin-top:6px; display:block; }
  .small { font-size:13px; padding:6px 8px; }
  label{font-size:13px; color:#9fb4d9; display:block; margin-top:8px;}
  input[type="range"]{ width:100%; }
</style>
</head>
<body>
<div id="map"></div>

<div class="controls" aria-live="polite">
  <div style="display:flex;justify-content:space-between;align-items:center">
    <strong>Street-following Simulator</strong>
    <span style="font-size:12px;color:#9fb4d9">Synthetic only</span>
  </div>

  <div style="margin-top:8px">
    <button id="spawnBtn" class="btn-primary small">Add Agent</button>
    <button id="removeBtn" class="btn-ghost small">Remove Agent</button>
    <button id="pauseBtn" class="btn-ghost small">Pause</button>
  </div>

  <label>Speed multiplier: <span id="speedLabel">1.0×</span></label>
  <input id="speedRange" type="range" min="0.25" max="4" step="0.25" value="1">

  <label>Agent type</label>
  <select id="agentType" style="width:100%;padding:6px;border-radius:6px">
    <option value="walk">Pedestrian (~1.4 m/s)</option>
    <option value="bike">Cyclist (~5 m/s)</option>
    <option value="drive">Car (~13 m/s)</option>
  </select>

  <div class="muted">Click map to set a custom target for the last spawned agent (synthetic only).</div>
  <div class="muted" style="margin-top:8px">Routing by OSRM public demo server. This demo is for testing/visual only. Do not use to track real people.</div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
/*
  Street-following Simulator (single HTML)
  - Synthetic agents follow real street geometry retrieved from OSRM (public demo).
  - Agents choose random origins/destinations inside the current map bounds.
  - Movement is purely simulated: positions are not tied to any real device/user.
  - Do NOT use for tracking real people.
*/

/* --- Config --- */
const OSRM_BASE = 'https://router.project-osrm.org'; // public demo (use responsibly)
const DEFAULT_AGENT_COUNTS = 2;
const WALK_SPEED = 1.4; // m/s
const BIKE_SPEED = 5.0; // m/s
const DRIVE_SPEED = 13.0; // m/s

/* --- Setup map --- */
const map = L.map('map', {zoomControl:true}).setView([48.8566, 2.3522], 13); // default: Paris
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

/* --- Utilities --- */
function haversine(a, b) {
  const R = 6371000;
  const toRad = x => x * Math.PI/180;
  const dLat = toRad(b.lat - a.lat);
  const dLon = toRad(b.lng - a.lng);
  const lat1 = toRad(a.lat);
  const lat2 = toRad(b.lat);
  const sinDlat = Math.sin(dLat/2);
  const sinDlon = Math.sin(dLon/2);
  const aa = sinDlat*sinDlat + Math.cos(lat1)*Math.cos(lat2)*sinDlon*sinDlon;
  const c = 2 * Math.atan2(Math.sqrt(aa), Math.sqrt(1-aa));
  return R * c;
}

function lerpLatLng(a,b,t){
  return { lat: a.lat + (b.lat - a.lat)*t, lng: a.lng + (b.lng - a.lng)*t };
}

/* --- Agent model --- */
class Agent {
  constructor(id, routeGeo, baseSpeed, color){
    this.id = id;
    this.route = routeGeo; // array of [lng,lat] pairs from OSRM geojson coordinates
    // convert to LatLng objects and compute cumulative distances
    this.points = this.route.map(c => ({lat:c[1], lng:c[0]}));
    this.distances = [0];
    for(let i=1;i<this.points.length;i++){
      this.distances[i] = this.distances[i-1] + haversine(this.points[i-1], this.points[i]);
    }
    this.total = this.distances[this.distances.length-1] || 0;
    this.progress = 0; // meters along route
    this.baseSpeed = baseSpeed; // m/s
    this.color = color || '#ff7f0e';
    // Leaflet representation
    this.marker = L.circleMarker(this.points[0], {radius:7, fillColor:this.color, color:'#001219', weight:1, fillOpacity:1}).addTo(map);
    this.polyline = L.polyline(this.points, {color:this.color, opacity:0.7}).addTo(map);
    this.trail = L.polyline([], {color:this.color, opacity:0.9, weight:3}).addTo(map);
    this.finished = false;
  }

  getPositionAt(progressMeters){
    if(this.total <= 0) return this.points[0];
    if(progressMeters <= 0) return this.points[0];
    if(progressMeters >= this.total) return this.points[this.points.length-1];
    // find segment
    let i = 0;
    while(i+1 < this.distances.length && this.distances[i+1] < progressMeters) i++;
    const segStartDist = this.distances[i];
    const segRatio = (progressMeters - segStartDist) / (this.distances[i+1] - segStartDist);
    return lerpLatLng(this.points[i], this.points[i+1], segRatio);
  }

  step(dt, speedMultiplier){
    if(this.finished) return;
    const travel = this.baseSpeed * speedMultiplier * dt; // meters
    this.progress += travel;
    if(this.progress >= this.total){
      this.progress = this.total;
      this.finished = true;
    }
    const pos = this.getPositionAt(this.progress);
    this.marker.setLatLng(pos);
    // extend trail
    const latlng = L.latLng(pos.lat, pos.lng);
    const arr = this.trail.getLatLngs();
    arr.push(latlng);
    if(arr.length > 200) arr.shift();
    this.trail.setLatLngs(arr);
  }

  remove(){
    map.removeLayer(this.marker);
    map.removeLayer(this.polyline);
    map.removeLayer(this.trail);
  }
}

/* --- Simulation manager --- */
const agents = new Map();
let nextAgentId = 1;
let running = true;
let speedMultiplier = 1.0;

/* --- UI elements --- */
const spawnBtn = document.getElementById('spawnBtn');
const removeBtn = document.getElementById('removeBtn');
const pauseBtn = document.getElementById('pauseBtn');
const speedRange = document.getElementById('speedRange');
const speedLabel = document.getElementById('speedLabel');
const agentTypeSel = document.getElementById('agentType');

speedRange.addEventListener('input', ()=>{
  speedMultiplier = parseFloat(speedRange.value);
  speedLabel.textContent = speedMultiplier.toFixed(2) + '×';
});

pauseBtn.addEventListener('click', ()=>{
  running = !running;
  pauseBtn.textContent = running ? 'Pause' : 'Resume';
});

removeBtn.addEventListener('click', ()=>{
  // remove last agent
  const keys = Array.from(agents.keys());
  if(!keys.length) return;
  const last = keys[keys.length-1];
  agents.get(last).remove();
  agents.delete(last);
});

/* Click map to set a target for last agent (synthetic only) */
map.on('click', async (e) => {
  const keys = Array.from(agents.keys());
  if(!keys.length) return;
  const lastId = keys[keys.length-1];
  // compute route from current marker to clicked point
  const lastAgent = agents.get(lastId);
  if(!lastAgent) return;
  // origin = agent current position, dest = clicked point
  const origin = lastAgent.marker.getLatLng();
  const dest = e.latlng;
  try {
    const geo = await fetchRouteGeojson(origin, dest, agentTypeSel.value);
    if(!geo || !geo.coordinates || !geo.coordinates.length) return;
    // remove existing layers and replace with new
    lastAgent.remove();
    const speed = getBaseSpeed(agentTypeSel.value);
    const color = pickColor();
    const agent = new Agent(lastId, geo.coordinates, speed, color);
    agent.progress = 0;
    agents.set(lastId, agent);
  } catch(err){
    console.warn('route fail', err);
    alert('Failed to compute route (routing service error). Try again or move map.');
  }
});

/* Spawn handler */
spawnBtn.addEventListener('click', async ()=>{
  try {
    spawnBtn.disabled = true;
    const bounds = map.getBounds();
    const origin = randomPointInBounds(bounds);
    const dest = randomPointInBounds(bounds);
    const profile = agentTypeSel.value;
    const geo = await fetchRouteGeojson(origin, dest, profile);
    if(!geo || !geo.coordinates || geo.coordinates.length < 2) {
      alert('Routing failed; try again or pan/zoom the map to an area with streets.');
      spawnBtn.disabled = false;
      return;
    }
    const id = 'agent-' + String(nextAgentId++).padStart(3,'0');
    const speed = getBaseSpeed(profile);
    const color = pickColor();
    const agent = new Agent(id, geo.coordinates, speed, color);
    agents.set(id, agent);
    spawnBtn.disabled = false;
  } catch(err){
    console.error(err);
    alert('Error fetching route. Check network or try a different area.');
    spawnBtn.disabled = false;
  }
});

/* initial spawn */
(async ()=> {
  for(let i=0;i<DEFAULT_AGENT_COUNTS;i++){
    spawnBtn.click();
    // slight delay to avoid hammering routing server
    await new Promise(r => setTimeout(r, 250));
  }
})();

/* --- Helpers --- */
function pickColor(){
  const pal = ['#ff7f0e','#2ca02c','#1f77b4','#d62728','#9467bd','#8c564b','#e377c2','#7f7f7f'];
  return pal[Math.floor(Math.random()*pal.length)];
}

function getBaseSpeed(type){
  if(type === 'walk') return WALK_SPEED;
  if(type === 'bike') return BIKE_SPEED;
  return DRIVE_SPEED;
}

function randomPointInBounds(bounds){
  const south = bounds.getSouth();
  const north = bounds.getNorth();
  const west = bounds.getWest();
  const east = bounds.getEast();
  return L.latLng(rand(south,north), rand(west,east));
}

function rand(a,b){ return Math.random()*(b-a)+a; }

/* fetch route from OSRM (geojson) */
/* profile: 'walk' -> use driving profile with OSRM public; OSRM demo supports car profile only on public endpoint.
   For this demo we use 'driving' for car and bike and walk for simplicity; route profiles vary by deployment.
   NOTE: Public OSRM demo primarily supports driving; for true walking/biking you'd need a server with those profiles.
*/
async function fetchRouteGeojson(aLatLng, bLatLng, agentProfile = 'drive'){
  // choose profile param - map agentProfile to OSRM profile string (public demo primarily supports 'driving')
  const profile = 'driving'; // using driving for all so shapes follow drivable roads on public service
  const coords = `${aLatLng.lng},${aLatLng.lat};${bLatLng.lng},${bLatLng.lat}`;
  const url = `${OSRM_BASE}/route/v1/${profile}/${coords}?overview=full&geometries=geojson&steps=false`;
  const res = await fetch(url);
  if(!res.ok) throw new Error('Routing error: ' + res.status);
  const data = await res.json();
  if(!data.routes || !data.routes.length) return null;
  return data.routes[0].geometry;
}

/* --- Animator --- */
let lastTS = performance.now();
function animate(ts){
  const dt = (ts - lastTS)/1000;
  lastTS = ts;
  if(running){
    for(const agent of agents.values()){
      agent.step(dt, speedMultiplier);
    }
  }
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

/* --- Accessibility / cleanup --- */
window.addEventListener('beforeunload', ()=> {
  // remove leaflet layers (not necessary but tidy)
  agents.forEach(a => a.remove());
});

</script>
</body>
</html>
